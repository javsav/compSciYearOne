          Original Vectors                            Expected Output                               Matlab Output
     A                      B                             New A                                       New A
 [1.2: 1.2 : 6]        [-1.2: -1.2: -6]       1, 2, 4, 5, 6, -6, -5, -4, -2, -1              1, 2, 4, 5, 6, -6, -5, -4, -2, -1
[1.3, "two", '2.8']    ['Euler', 5, "flower"]      1, NaN, NaN, NaN, 5, NaN OR throws error       1.3, two, 2.8, flower, 5, Euler
 ['x':'z']            [23.33 : -1 : 20.33]      x, y, z, 20.33, 21.33, 22.33, 23.33                x, y, z, , , , 

Note that I am as opposed to question 2a, I am using vectors instead of cells, making the script much shorter

Test case 1 evaluates the rounding of floats, ranges of numbers with a float increment, and negative numbers. As expected, we see a vector that has half
positive numbers, and half negative numbers. The negative numbers are the positive numbers multiplied by 1, in reverse order.

I was surprised with the result of test case 2, as I did not realise that vectors could be used for multiple primitive classes.
Test case 2 tests a combination of floats, integers, character vectors and string arrays, however it also taught me why cells are 
preferred for lists containing multiple primitve classes. As each vector contains multiple classes, MATLAB has used type coercion to convert all values to strings. 
This means that I am unable to round them to a whole integer, unless I use the function str2num, but this would be difficult to implement in a systematic
way using vectors. Other than not rounding the floats to integers, the output is correct!

Test case 3 further highlights the practicality of using cells for multiple classes of data, as the use of a character vector (that was generated by 'x':'z')
caused the integers to display as square boxes devoid of any value. We know from test case 2, character vectors, such as 'Euler', can be displayed
by this script. This suggests that the generation of the vector A using ['x':'z'] is the causative factor of the error here, and that A = ["x", 'y', "z"]
would have returned x, y, z, 20.33, 21.33, 22.33, 23.33 (slightly more correct but still does not round the floats like the script using cells did).
However, A = ['x', 'y', 'z'] would have returned the same output, as A would then be equal to a character vector. This means when appending floats or
integers, the original vector to which they are being appended needs to have multiple classes of data in order for the type coercion from float to string to
occur.